/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * silex-admin
 * silex-admin api
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:{port}/api/{basePath}".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch,
    ) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Base
 */
export interface Base {
    /**
     *
     * @type {string}
     * @memberof Base
     */
    id: string;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    active: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    _delete: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    system: boolean;
    /**
     *
     * @type {Date}
     * @memberof Base
     */
    createTime: Date;
    /**
     *
     * @type {Date}
     * @memberof Base
     */
    createBy: Date;
    /**
     *
     * @type {string}
     * @memberof Base
     */
    updateTime: string;
    /**
     *
     * @type {string}
     * @memberof Base
     */
    updateBy: string;
    /**
     *
     * @type {string}
     * @memberof Base
     */
    release: string;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    last: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    canUpdate: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Base
     */
    schemaUpdate: boolean;
}

/**
 *
 * @export
 * @interface BaseWidget
 */
export interface BaseWidget extends Base {
    /**
     *
     * @type {JSONSchema}
     * @memberof BaseWidget
     */
    schema: JSONSchema;
}

/**
 *
 * @export
 * @interface CustomUISchema
 */
export interface CustomUISchema {
    /**
     *
     * @type {UISchema}
     * @memberof CustomUISchema
     */
    uiSchema?: UISchema;
    /**
     *
     * @type {JSONSchema}
     * @memberof CustomUISchema
     */
    schema: JSONSchema;
}

/**
 *
 * @export
 * @interface Data
 */
export interface Data extends Base {
    /**
     *
     * @type {any}
     * @memberof Data
     */
    data?: any;
}

/**
 *
 * @export
 * @interface Entire
 */
export interface Entire extends BaseWidget {
    /**
     *
     * @type {UISchema}
     * @memberof Entire
     */
    uiSchema: UISchema;
    /**
     *
     * @type {CustomUISchema}
     * @memberof Entire
     */
    customUISchema?: CustomUISchema;

    uiDefinitions?: { [key: string]: any } & UISchema & JSONSchema;

    definitions?: any;

    formData?: any;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum InputTypeEnum {
    Button = "button",
    Checkbox = "checkbox",
    File = "file",
    Hidden = "hidden",
    Image = "image",
    Password = "password",
    Radio = "radio",
    Reset = "reset",
    Submit = "submit",
    Text = "text",
    Email = "email",
    Url = "url",
    Number = "number",
    Range = "range",
    Date = "date",
    Month = "month",
    Week = "week",
    Time = "time",
    Datetime = "datetime",
    DatetimeLocal = "datetime-local",
}

/**
 *
 * @export
 * @interface JSONSchema
 */
export interface JSONSchema {
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    $id?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    $schema?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    $ref?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    $comment?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    description?: string;
    /**
     *
     * @type {any}
     * @memberof JSONSchema
     */
    _default?: any;
    /**
     *
     * @type {boolean}
     * @memberof JSONSchema
     */
    readOnly?: boolean;
    /**
     *
     * @type {Array<any>}
     * @memberof JSONSchema
     */
    examples?: Array<any>;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    multipleOf?: number;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    maximum?: number;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    exclusiveMaximum?: number;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    minimum?: number;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    exclusiveMinimum?: number;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    maxLength?: number;
    /**
     *
     * @type {NonNegativeIntegerDefault0}
     * @memberof JSONSchema
     */
    minLength?: NonNegativeIntegerDefault0;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    pattern?: string;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    additionalItems?: JSONSchema;
    /**
     *
     * @type {any}
     * @memberof JSONSchema
     */
    items?: any;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    maxItems?: number;
    /**
     *
     * @type {NonNegativeIntegerDefault0}
     * @memberof JSONSchema
     */
    minItems?: NonNegativeIntegerDefault0;
    /**
     *
     * @type {boolean}
     * @memberof JSONSchema
     */
    uniqueItems?: boolean;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    contains?: JSONSchema;
    /**
     *
     * @type {number}
     * @memberof JSONSchema
     */
    maxProperties?: number;
    /**
     *
     * @type {NonNegativeIntegerDefault0}
     * @memberof JSONSchema
     */
    minProperties?: NonNegativeIntegerDefault0;
    /**
     *
     * @type {StringArray}
     * @memberof JSONSchema
     */
    required?: StringArray;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    additionalProperties?: JSONSchema;
    /**
     *
     * @type {{ [key: string]: JSONSchema; }}
     * @memberof JSONSchema
     */
    definitions?: { [key: string]: JSONSchema };
    /**
     *
     * @type {{ [key: string]: JSONSchema; }}
     * @memberof JSONSchema
     */
    properties?: { [key: string]: JSONSchema };
    /**
     *
     * @type {{ [key: string]: JSONSchema; }}
     * @memberof JSONSchema
     */
    patternProperties?: { [key: string]: JSONSchema };
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof JSONSchema
     */
    dependencies?: { [key: string]: any };
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    propertyNames?: JSONSchema;
    /**
     *
     * @type {any}
     * @memberof JSONSchema
     */
    _const?: any;
    /**
     *
     * @type {Array<string>}
     * @memberof JSONSchema
     */
    _enum?: Array<string>;
    /**
     *
     * @type {any}
     * @memberof JSONSchema
     */
    type?: any;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    contentMediaType?: string;
    /**
     *
     * @type {string}
     * @memberof JSONSchema
     */
    contentEncoding?: string;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    _if?: JSONSchema;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    then?: JSONSchema;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    _else?: JSONSchema;
    /**
     *
     * @type {SchemaArray}
     * @memberof JSONSchema
     */
    allOf?: SchemaArray;
    /**
     *
     * @type {SchemaArray}
     * @memberof JSONSchema
     */
    anyOf?: SchemaArray;
    /**
     *
     * @type {SchemaArray}
     * @memberof JSONSchema
     */
    oneOf?: SchemaArray;
    /**
     *
     * @type {JSONSchema}
     * @memberof JSONSchema
     */
    not?: JSONSchema;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}

/**
 *
 * @export
 * @interface NonNegativeIntegerDefault0
 */
export interface NonNegativeIntegerDefault0 {}

/**
 *
 * @export
 * @interface Option
 */
export interface Option extends BaseWidget {
    /**
     *
     * @type {UISchema}
     * @memberof Option
     */
    uiSchema: UISchema;
}

/**
 *
 * @export
 * @interface SchemaArray
 */
export interface SchemaArray extends Array<JSONSchema> {}

/**
 *
 * @export
 * @enum {string}
 */
export enum SimpleTypes {
    Array = "array",
    Boolean = "boolean",
    Integer = "integer",
    Null = "null",
    Number = "number",
    Object = "object",
    String = "string",
}

/**
 *
 * @export
 * @interface StringArray
 */
export interface StringArray extends Array<string> {}

/**
 *
 * @export
 * @interface Template
 */
export interface Template extends Entire {}

/**
 *
 * @export
 * @interface TemplateIntance
 */
export interface TemplateIntance {
    /**
     *
     * @type {string}
     * @memberof TemplateIntance
     */
    aa?: string;
}

/**
 *
 * @export
 * @interface UISchema
 */
export interface UISchema {
    /**
     *
     * @type {Uiwidget}
     * @memberof UISchema
     */
    ui$widget?: Uiwidget;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    classNames?: string;
    /**
     *
     * @type {any}
     * @memberof UISchema
     */
    ui$options?: any;
    /**
     *
     * @type {boolean}
     * @memberof UISchema
     */
    ui$disabled?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UISchema
     */
    ui$readonly?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof UISchema
     */
    ui$order?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof UISchema
     */
    ui$enumDisabled?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    ui$rootFieldId?: string;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    ui$help?: string;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    ui$title?: string;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    ui$description?: string;
    /**
     *
     * @type {boolean}
     * @memberof UISchema
     */
    ui$autofocus?: boolean;
    /**
     *
     * @type {string}
     * @memberof UISchema
     */
    ui$placeholder?: string;
    /**
     *
     * @type {any}
     * @memberof UISchema
     */
    ui$emptyValue?: any;
    /**
     *
     * @type {boolean}
     * @memberof UISchema
     */
    ui$print?: boolean;
}

/**
 *
 * @export
 * @interface Uioptions
 */
export interface Uioptions {}

/**
 *
 * @export
 * @enum {string}
 */
export enum Uiwidget {
    Checkbox = "checkbox",
    Radio = "radio",
    Select = "select",
    Hidden = "hidden",
    Text = "text",
    Password = "password",
    Email = "email",
    Hostname = "hostname",
    Ipv4 = "ipv4",
    Ipv6 = "ipv6",
    Uri = "uri",
    DataUrl = "data-url",
    Textarea = "textarea",
    Date = "date",
    Datetime = "datetime",
    DateTime = "date-time",
    AltDate = "alt-date",
    AltDatetime = "alt-datetime",
    Color = "color",
    Updown = "updown",
    Range = "range",
    File = "file",
    Checkboxes = "checkboxes",
    Files = "files",
}

/**
 *
 * @export
 * @interface Widget
 */
export interface Widget {}

/**
 * DataApi - fetch parameter creator
 * @export
 */
export const DataApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addData(data?: Data, options: any = {}): FetchArgs {
            const localVarPath = `/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "POST" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Data" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(data || {})
                : data || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getDataById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    "id",
                    "Required parameter id was null or undefined when calling getDataById.",
                );
            }
            const localVarPath = `/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getDatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatas(options: any = {}): FetchArgs {
            const localVarPath = `/data/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary updateData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData(data?: Data, options: any = {}): FetchArgs {
            const localVarPath = `/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "PUT" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Data" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(data || {})
                : data || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addData(
            data?: Data,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Data>> {
            const localVarFetchArgs = DataApiFetchParamCreator(configuration).addData(
                data,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getDataById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataById(
            id: string,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Data> {
            const localVarFetchArgs = DataApiFetchParamCreator(configuration).getDataById(
                id,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getDatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatas(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Data>> {
            const localVarFetchArgs = DataApiFetchParamCreator(configuration).getDatas(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary updateData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData(
            data?: Data,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Data>> {
            const localVarFetchArgs = DataApiFetchParamCreator(configuration).updateData(
                data,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
    };
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string,
) {
    return {
        /**
         *
         * @summary addData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addData(data?: Data, options?: any) {
            return DataApiFp(configuration).addData(data, options)(fetch, basePath);
        },
        /**
         *
         * @summary getDataById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataById(id: string, options?: any) {
            return DataApiFp(configuration).getDataById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary getDatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatas(options?: any) {
            return DataApiFp(configuration).getDatas(options)(fetch, basePath);
        },
        /**
         *
         * @summary updateData
         * @param {Data} [data]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData(data?: Data, options?: any) {
            return DataApiFp(configuration).updateData(data, options)(fetch, basePath);
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     *
     * @summary addData
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public addData(data?: Data, options?: any) {
        return DataApiFp(this.configuration).addData(data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getDataById
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public getDataById(id: string, options?: any) {
        return DataApiFp(this.configuration).getDataById(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getDatas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public getDatas(options?: any) {
        return DataApiFp(this.configuration).getDatas(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary updateData
     * @param {Data} [data]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public updateData(data?: Data, options?: any) {
        return DataApiFp(this.configuration).updateData(data, options)(this.fetch, this.basePath);
    }
}

/**
 * OptionApi - fetch parameter creator
 * @export
 */
export const OptionApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOption(option?: Option, options: any = {}): FetchArgs {
            const localVarPath = `/option`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "POST" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Option" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(option || {})
                : option || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/template/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary updateOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOption(option?: Option, options: any = {}): FetchArgs {
            const localVarPath = `/option`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "PUT" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Option" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(option || {})
                : option || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * OptionApi - functional programming interface
 * @export
 */
export const OptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOption(
            option?: Option,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Option>> {
            const localVarFetchArgs = OptionApiFetchParamCreator(configuration).addOption(
                option,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Template>> {
            const localVarFetchArgs = OptionApiFetchParamCreator(configuration).getTemplates(
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary updateOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOption(
            option?: Option,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Option>> {
            const localVarFetchArgs = OptionApiFetchParamCreator(configuration).updateOption(
                option,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
    };
};

/**
 * OptionApi - factory interface
 * @export
 */
export const OptionApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string,
) {
    return {
        /**
         *
         * @summary addOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOption(option?: Option, options?: any) {
            return OptionApiFp(configuration).addOption(option, options)(fetch, basePath);
        },
        /**
         *
         * @summary getTemplates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: any) {
            return OptionApiFp(configuration).getTemplates(options)(fetch, basePath);
        },
        /**
         *
         * @summary updateOption
         * @param {Option} [option]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOption(option?: Option, options?: any) {
            return OptionApiFp(configuration).updateOption(option, options)(fetch, basePath);
        },
    };
};

/**
 * OptionApi - object-oriented interface
 * @export
 * @class OptionApi
 * @extends {BaseAPI}
 */
export class OptionApi extends BaseAPI {
    /**
     *
     * @summary addOption
     * @param {Option} [option]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public addOption(option?: Option, options?: any) {
        return OptionApiFp(this.configuration).addOption(option, options)(
            this.fetch,
            this.basePath,
        );
    }

    /**
     *
     * @summary getTemplates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public getTemplates(options?: any) {
        return OptionApiFp(this.configuration).getTemplates(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary updateOption
     * @param {Option} [option]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionApi
     */
    public updateOption(option?: Option, options?: any) {
        return OptionApiFp(this.configuration).updateOption(option, options)(
            this.fetch,
            this.basePath,
        );
    }
}

/**
 * TemplateApi - fetch parameter creator
 * @export
 */
export const TemplateApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(template?: Template, options: any = {}): FetchArgs {
            const localVarPath = `/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "POST" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Template" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(template || {})
                : template || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getTemplateId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    "id",
                    "Required parameter id was null or undefined when calling getTemplateId.",
                );
            }
            const localVarPath = `/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary updateTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(template?: Template, options: any = {}): FetchArgs {
            const localVarPath = `/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "PUT" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Template" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(template || {})
                : template || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(
            template?: Template,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Template>> {
            const localVarFetchArgs = TemplateApiFetchParamCreator(configuration).addTemplate(
                template,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getTemplateId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateId(
            id: string,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Template> {
            const localVarFetchArgs = TemplateApiFetchParamCreator(configuration).getTemplateId(
                id,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary updateTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(
            template?: Template,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Template>> {
            const localVarFetchArgs = TemplateApiFetchParamCreator(configuration).updateTemplate(
                template,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
    };
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string,
) {
    return {
        /**
         *
         * @summary addTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(template?: Template, options?: any) {
            return TemplateApiFp(configuration).addTemplate(template, options)(fetch, basePath);
        },
        /**
         *
         * @summary getTemplateId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateId(id: string, options?: any) {
            return TemplateApiFp(configuration).getTemplateId(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary updateTemplate
         * @param {Template} [template]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(template?: Template, options?: any) {
            return TemplateApiFp(configuration).updateTemplate(template, options)(fetch, basePath);
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     *
     * @summary addTemplate
     * @param {Template} [template]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public addTemplate(template?: Template, options?: any) {
        return TemplateApiFp(this.configuration).addTemplate(template, options)(
            this.fetch,
            this.basePath,
        );
    }

    /**
     *
     * @summary getTemplateId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getTemplateId(id: string, options?: any) {
        return TemplateApiFp(this.configuration).getTemplateId(id, options)(
            this.fetch,
            this.basePath,
        );
    }

    /**
     *
     * @summary updateTemplate
     * @param {Template} [template]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public updateTemplate(template?: Template, options?: any) {
        return TemplateApiFp(this.configuration).updateTemplate(template, options)(
            this.fetch,
            this.basePath,
        );
    }
}

/**
 * WidgetApi - fetch parameter creator
 * @export
 */
export const WidgetApiFetchParamCreator = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidget(body?: Entire, options: any = {}): FetchArgs {
            const localVarPath = `/widget`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "POST" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Entire" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getOptionId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionId(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    "id",
                    "Required parameter id was null or undefined when calling getOptionId.",
                );
            }
            const localVarPath = `/option`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getWidgetById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    "id",
                    "Required parameter id was null or undefined when calling getWidgetById.",
                );
            }
            const localVarPath = `/widget`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getWidgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgets(options: any = {}): FetchArgs {
            const localVarPath = `/widget/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "GET" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary updateWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidget(body?: Entire, options: any = {}): FetchArgs {
            const localVarPath = `/widget`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: "PUT" }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query,
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers,
            );
            const needsSerialization =
                <any>"Entire" !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || "";

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * WidgetApi - functional programming interface
 * @export
 */
export const WidgetApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary addWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidget(
            body?: Entire,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Widget>> {
            const localVarFetchArgs = WidgetApiFetchParamCreator(configuration).addWidget(
                body,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                (response) => {
                  if (response.status >= 200 && response.status < 300) {
                    return response.json();
                  } else {
                    throw response;
                  }
                },
              );
            };
        },
        /**
         *
         * @summary getOptionId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionId(
            id: string,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Option> {
            const localVarFetchArgs = WidgetApiFetchParamCreator(configuration).getOptionId(
                id,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getWidgetById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetById(
            id: string,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Entire> {
            const localVarFetchArgs = WidgetApiFetchParamCreator(configuration).getWidgetById(
                id,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary getWidgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgets(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Widget>> {
            const localVarFetchArgs = WidgetApiFetchParamCreator(configuration).getWidgets(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
        /**
         *
         * @summary updateWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidget(
            body?: Entire,
            options?: any,
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Widget>> {
            const localVarFetchArgs = WidgetApiFetchParamCreator(configuration).updateWidget(
                body,
                options,
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    },
                );
            };
        },
    };
};

/**
 * WidgetApi - factory interface
 * @export
 */
export const WidgetApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string,
) {
    return {
        /**
         *
         * @summary addWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidget(body?: Entire, options?: any) {
            return WidgetApiFp(configuration).addWidget(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary getOptionId
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionId(id: string, options?: any) {
            return WidgetApiFp(configuration).getOptionId(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary getWidgetById
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetById(id: string, options?: any) {
            return WidgetApiFp(configuration).getWidgetById(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary getWidgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgets(options?: any) {
            return WidgetApiFp(configuration).getWidgets(options)(fetch, basePath);
        },
        /**
         *
         * @summary updateWidget
         * @param {Entire} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidget(body?: Entire, options?: any) {
            return WidgetApiFp(configuration).updateWidget(body, options)(fetch, basePath);
        },
    };
};

/**
 * WidgetApi - object-oriented interface
 * @export
 * @class WidgetApi
 * @extends {BaseAPI}
 */
export class WidgetApi extends BaseAPI {
    /**
     *
     * @summary addWidget
     * @param {Entire} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetApi
     */
    public addWidget(body?: Entire, options?: any) {
        return WidgetApiFp(this.configuration).addWidget(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getOptionId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetApi
     */
    public getOptionId(id: string, options?: any) {
        return WidgetApiFp(this.configuration).getOptionId(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getWidgetById
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetApi
     */
    public getWidgetById(id: string, options?: any) {
        return WidgetApiFp(this.configuration).getWidgetById(id, options)(
            this.fetch,
            this.basePath,
        );
    }

    /**
     *
     * @summary getWidgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetApi
     */
    public getWidgets(options?: any) {
        return WidgetApiFp(this.configuration).getWidgets(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary updateWidget
     * @param {Entire} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetApi
     */
    public updateWidget(body?: Entire, options?: any) {
        return WidgetApiFp(this.configuration).updateWidget(body, options)(
            this.fetch,
            this.basePath,
        );
    }
}
